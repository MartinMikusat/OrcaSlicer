package main

import "core:fmt"
import "core:strings"
import "core:os"

// =============================================================================
// G-code Generation - Convert Print Paths to Machine Instructions
//
// This module converts print paths into G-code commands that 3D printers can
// execute. It handles movement commands, extrusion control, temperature
// management, and other essential printing operations.
//
// Architecture: Final stage of the print path pipeline
// =============================================================================

// =============================================================================
// G-code Generator Configuration
// =============================================================================

// G-code generation settings
GCodeSettings :: struct {
    // Printer configuration
    bed_temperature:      f32,      // Heated bed temperature 째C
    extruder_temperature: f32,      // Nozzle temperature 째C
    filament_diameter:    f64,      // Filament diameter in mm
    
    // Movement settings
    travel_speed:         f32,      // Travel speed mm/s
    z_hop_height:         f64,      // Z-hop for travel moves mm
    z_hop_speed:          f32,      // Z-hop speed mm/s
    
    // Extrusion settings
    retraction_distance:  f64,      // Retraction distance mm
    retraction_speed:     f32,      // Retraction speed mm/s
    extra_restart_length: f64,      // Extra filament on restart mm
    
    // Print area
    print_bed_size:       Point2D,  // Bed size in mm (as coordinates)
    
    // G-code flavor
    use_relative_extrusion: bool,   // True for relative E values
    use_firmware_retraction: bool,  // Use G10/G11 commands
}

// Default G-code settings
gcode_settings_default :: proc() -> GCodeSettings {
    return {
        bed_temperature = 60.0,
        extruder_temperature = 200.0,
        filament_diameter = 1.75,
        travel_speed = 150.0,
        z_hop_height = 0.2,
        z_hop_speed = 5.0,
        retraction_distance = 1.5,
        retraction_speed = 25.0,
        extra_restart_length = 0.0,
        print_bed_size = point2d_from_mm(200.0, 200.0),
        use_relative_extrusion = false,
        use_firmware_retraction = false,
    }
}

// =============================================================================
// G-code Generation State
// =============================================================================

// Current printer state for generating incremental commands
GCodeState :: struct {
    current_position: Vec3f,        // Current XYZ position in mm
    current_e_position: f64,        // Current extruder position
    current_feed_rate: f32,         // Current feed rate mm/min
    is_extruding: bool,             // True if filament is loaded
    layer_count: u32,               // Current layer number
}

// Initialize G-code generator state
gcode_state_create :: proc() -> GCodeState {
    return {
        current_position = {0, 0, 0},
        current_e_position = 0.0,
        current_feed_rate = 0.0,
        is_extruding = false,
        layer_count = 0,
    }
}

// =============================================================================
// G-code Generation Core Functions
// =============================================================================

// Generate complete G-code for a print job
generate_gcode :: proc(job: ^PrintJob, settings: GCodeSettings) -> string {
    builder := strings.builder_make()
    defer strings.builder_destroy(&builder)
    
    state := gcode_state_create()
    
    // Generate header
    generate_gcode_header(&builder, job^, settings)
    
    // Generate start sequence
    generate_start_sequence(&builder, &state, settings)
    
    // Generate layers
    for &layer in job.layers {
        generate_layer_gcode(&builder, &state, &layer, settings)
        state.layer_count += 1
    }
    
    // Generate end sequence
    generate_end_sequence(&builder, &state, settings)
    
    return strings.clone(strings.to_string(builder))
}

// Generate G-code header with metadata
generate_gcode_header :: proc(builder: ^strings.Builder, job: PrintJob, settings: GCodeSettings) {
    strings.write_string(builder, "; Generated by OrcaSlicer Odin\n")
    strings.write_string(builder, "; https://github.com/SoftFever/OrcaSlicer\n")
    strings.write_string(builder, ";\n")
    
    // Print statistics
    fmt.sbprintf(builder, "; Total layers: %d\n", len(job.layers))
    fmt.sbprintf(builder, "; Estimated print time: %.1f minutes\n", job.total_print_time / 60.0)
    fmt.sbprintf(builder, "; Filament used: %.2f m\n", job.total_filament / 1000.0)
    
    // Printer settings
    fmt.sbprintf(builder, "; Bed temperature: %.0f째C\n", settings.bed_temperature)
    fmt.sbprintf(builder, "; Extruder temperature: %.0f째C\n", settings.extruder_temperature)
    fmt.sbprintf(builder, "; Filament diameter: %.2f mm\n", settings.filament_diameter)
    strings.write_string(builder, ";\n")
}

// Generate printer start sequence
generate_start_sequence :: proc(builder: ^strings.Builder, state: ^GCodeState, settings: GCodeSettings) {
    strings.write_string(builder, "; Start sequence\n")
    
    // Set units to millimeters
    strings.write_string(builder, "G21 ; set units to millimeters\n")
    
    // Set absolute positioning
    strings.write_string(builder, "G90 ; use absolute coordinates\n")
    
    // Set extrusion mode
    if settings.use_relative_extrusion {
        strings.write_string(builder, "M83 ; use relative distances for extrusion\n")
    } else {
        strings.write_string(builder, "M82 ; use absolute distances for extrusion\n")
    }
    
    // Reset extruder position
    strings.write_string(builder, "G92 E0 ; reset extruder position\n")
    state.current_e_position = 0.0
    
    // Home axes
    strings.write_string(builder, "G28 ; home all axes\n")
    state.current_position = {0, 0, 0}
    
    // Heat bed
    fmt.sbprintf(builder, "M140 S%.0f ; set bed temperature\n", settings.bed_temperature)
    
    // Heat extruder
    fmt.sbprintf(builder, "M104 S%.0f ; set extruder temperature\n", settings.extruder_temperature)
    
    // Wait for bed temperature
    fmt.sbprintf(builder, "M190 S%.0f ; wait for bed temperature\n", settings.bed_temperature)
    
    // Wait for extruder temperature
    fmt.sbprintf(builder, "M109 S%.0f ; wait for extruder temperature\n", settings.extruder_temperature)
    
    // Prime extruder
    strings.write_string(builder, "G1 Z2.0 F3000 ; move Z to 2mm\n")
    strings.write_string(builder, "G1 X10.1 Y20 Z0.28 F5000.0 ; move to start position\n")
    strings.write_string(builder, "G1 X10.1 Y200.0 Z0.28 F1500.0 E15 ; draw 1st line\n")
    strings.write_string(builder, "G1 X10.4 Y200.0 Z0.28 F5000.0 ; move to side a little\n")
    strings.write_string(builder, "G1 X10.4 Y20 Z0.28 F1500.0 E30 ; draw 2nd line\n")
    strings.write_string(builder, "G92 E0 ; reset extruder\n")
    
    state.current_e_position = 0.0
    state.is_extruding = true
    
    strings.write_string(builder, ";\n")
}

// Generate G-code for a single layer
generate_layer_gcode :: proc(builder: ^strings.Builder, state: ^GCodeState, 
                            layer: ^PrintLayer, settings: GCodeSettings) {
    
    fmt.sbprintf(builder, "; LAYER %d\n", state.layer_count)
    fmt.sbprintf(builder, "; Z: %.3f\n", layer.z_height)
    
    // Move to layer height
    if abs(state.current_position.z - layer.z_height) > 0.01 {
        fmt.sbprintf(builder, "G1 Z%.3f F%.0f ; move to layer height\n", 
                     layer.z_height, settings.z_hop_speed * 60.0)
        state.current_position.z = layer.z_height
    }
    
    // Generate paths for this layer
    for &path in layer.paths {
        generate_path_gcode(builder, state, &path, settings)
    }
    
    strings.write_string(builder, ";\n")
}

// Generate G-code for a single print path
generate_path_gcode :: proc(builder: ^strings.Builder, state: ^GCodeState,
                           path: ^PrintPath, settings: GCodeSettings) {
    
    // Add path comment
    fmt.sbprintf(builder, "; Path: %v (%d moves)\n", path.type, len(path.moves))
    
    if len(path.moves) == 0 do return
    
    // Move to start of path if needed
    first_move := &path.moves[0]
    start_mm := Vec2f{f32(coord_to_mm(first_move.start.x)), f32(coord_to_mm(first_move.start.y))}
    
    if abs(state.current_position.x - f32(start_mm.x)) > 0.01 || 
       abs(state.current_position.y - f32(start_mm.y)) > 0.01 {
        
        // Retract before travel if we were extruding
        if state.is_extruding && !settings.use_firmware_retraction {
            retract_gcode(builder, state, settings)
        }
        
        // Travel move
        fmt.sbprintf(builder, "G0 X%.3f Y%.3f F%.0f ; travel to start\n",
                     start_mm.x, start_mm.y, settings.travel_speed * 60.0)
        
        state.current_position.x = f32(start_mm.x)
        state.current_position.y = f32(start_mm.y)
        
        // Unretract after travel
        if !state.is_extruding && !settings.use_firmware_retraction {
            unretract_gcode(builder, state, settings)
        }
    }
    
    // Generate moves for this path
    for &move in path.moves {
        generate_move_gcode(builder, state, &move, settings)
    }
}

// Generate G-code for a single print move
generate_move_gcode :: proc(builder: ^strings.Builder, state: ^GCodeState,
                           move: ^PrintMove, settings: GCodeSettings) {
    
    end_mm := Vec2f{f32(coord_to_mm(move.end.x)), f32(coord_to_mm(move.end.y))}
    
    switch move.type {
    case .TRAVEL:
        // Non-printing move
        feed_rate := move.speed * 60.0 // Convert mm/s to mm/min
        fmt.sbprintf(builder, "G0 X%.3f Y%.3f F%.0f\n",
                     end_mm.x, end_mm.y, feed_rate)
        
        state.current_position.x = f32(end_mm.x)
        state.current_position.y = f32(end_mm.y)
        state.current_feed_rate = feed_rate
        
    case .EXTRUDE:
        // Printing move with extrusion
        feed_rate := move.speed * 60.0 // Convert mm/s to mm/min
        
        // Calculate extrusion amount
        move_distance := coord_to_mm(point_distance(move.start, move.end))
        extrusion_amount := move_distance * f64(move.extrusion_rate)
        
        if settings.use_relative_extrusion {
            fmt.sbprintf(builder, "G1 X%.3f Y%.3f E%.5f F%.0f\n",
                         end_mm.x, end_mm.y, extrusion_amount, feed_rate)
        } else {
            state.current_e_position += extrusion_amount
            fmt.sbprintf(builder, "G1 X%.3f Y%.3f E%.5f F%.0f\n",
                         end_mm.x, end_mm.y, state.current_e_position, feed_rate)
        }
        
        state.current_position.x = f32(end_mm.x)
        state.current_position.y = f32(end_mm.y)
        state.current_feed_rate = feed_rate
        state.is_extruding = true
        
    case .RETRACT:
        retract_gcode(builder, state, settings)
        
    case .UNRETRACT:
        unretract_gcode(builder, state, settings)
    }
}

// Generate retraction G-code
retract_gcode :: proc(builder: ^strings.Builder, state: ^GCodeState, settings: GCodeSettings) {
    if !state.is_extruding do return
    
    if settings.use_firmware_retraction {
        strings.write_string(builder, "G10 ; retract\n")
    } else {
        retract_speed := settings.retraction_speed * 60.0 // Convert to mm/min
        
        if settings.use_relative_extrusion {
            fmt.sbprintf(builder, "G1 E-%.3f F%.0f ; retract\n",
                         settings.retraction_distance, retract_speed)
        } else {
            state.current_e_position -= settings.retraction_distance
            fmt.sbprintf(builder, "G1 E%.5f F%.0f ; retract\n",
                         state.current_e_position, retract_speed)
        }
    }
    
    state.is_extruding = false
}

// Generate unretraction G-code
unretract_gcode :: proc(builder: ^strings.Builder, state: ^GCodeState, settings: GCodeSettings) {
    if state.is_extruding do return
    
    if settings.use_firmware_retraction {
        strings.write_string(builder, "G11 ; unretract\n")
    } else {
        retract_speed := settings.retraction_speed * 60.0 // Convert to mm/min
        restart_amount := settings.retraction_distance + settings.extra_restart_length
        
        if settings.use_relative_extrusion {
            fmt.sbprintf(builder, "G1 E%.3f F%.0f ; unretract\n",
                         restart_amount, retract_speed)
        } else {
            state.current_e_position += restart_amount
            fmt.sbprintf(builder, "G1 E%.5f F%.0f ; unretract\n",
                         state.current_e_position, retract_speed)
        }
    }
    
    state.is_extruding = true
}

// Generate printer end sequence
generate_end_sequence :: proc(builder: ^strings.Builder, state: ^GCodeState, settings: GCodeSettings) {
    strings.write_string(builder, "; End sequence\n")
    
    // Retract filament
    if state.is_extruding {
        retract_gcode(builder, state, settings)
    }
    
    // Turn off heaters
    strings.write_string(builder, "M104 S0 ; turn off extruder\n")
    strings.write_string(builder, "M140 S0 ; turn off bed\n")
    
    // Move away from print
    strings.write_string(builder, "G1 X0 Y200 F3000 ; present print\n")
    
    // Raise Z
    fmt.sbprintf(builder, "G1 Z%.1f F3000 ; raise Z\n", state.current_position.z + 10.0)
    
    // Turn off motors
    strings.write_string(builder, "M84 ; disable motors\n")
    
    strings.write_string(builder, "; Print completed\n")
}

// =============================================================================
// G-code File Output
// =============================================================================

// Save G-code to file
save_gcode_to_file :: proc(gcode: string, filename: string) -> bool {
    handle, err := os.open(filename, os.O_WRONLY | os.O_CREATE | os.O_TRUNC, 0o644)
    if err != os.ERROR_NONE {
        fmt.printf("Error: Could not open file %s for writing\n", filename)
        return false
    }
    defer os.close(handle)
    
    _, write_err := os.write_string(handle, gcode)
    if write_err != os.ERROR_NONE {
        fmt.printf("Error: Could not write G-code to file %s\n", filename)
        return false
    }
    
    return true
}

// =============================================================================
// G-code Analysis and Validation
// =============================================================================

// Analyze G-code for statistics
analyze_gcode :: proc(gcode: string) -> GCodeAnalysis {
    lines := strings.split(gcode, "\n")
    defer delete(lines)
    
    analysis := GCodeAnalysis{}
    
    for line in lines {
        trimmed := strings.trim_space(line)
        if len(trimmed) == 0 || strings.has_prefix(trimmed, ";") {
            analysis.comment_lines += 1
            continue
        }
        
        analysis.command_lines += 1
        
        if strings.has_prefix(trimmed, "G0") || strings.has_prefix(trimmed, "G1") {
            analysis.movement_commands += 1
        }
        
        if strings.contains(trimmed, "E") && !strings.contains(trimmed, "G92") {
            analysis.extrusion_commands += 1
        }
    }
    
    analysis.total_lines = u32(len(lines))
    return analysis
}

// G-code analysis result
GCodeAnalysis :: struct {
    total_lines:        u32,
    command_lines:      u32,
    comment_lines:      u32,
    movement_commands:  u32,
    extrusion_commands: u32,
}

// Print G-code analysis summary
print_gcode_analysis :: proc(analysis: GCodeAnalysis) {
    fmt.printf("G-code Analysis:\n")
    fmt.printf("  Total lines: %d\n", analysis.total_lines)
    fmt.printf("  Command lines: %d\n", analysis.command_lines)
    fmt.printf("  Comment lines: %d\n", analysis.comment_lines)
    fmt.printf("  Movement commands: %d\n", analysis.movement_commands)
    fmt.printf("  Extrusion commands: %d\n", analysis.extrusion_commands)
}